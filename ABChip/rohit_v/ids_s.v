//***** Copyright 2015 All Rights Reserved. *****
//
//*** This file is auto generated by IDesignSpec (http://www.agnisys.com) . Please do not edit this file. ***
// created by        : dkb
// generated by      : dkb
// generated from    : F:\Jagnesh\work\iss\formal\ids_s.docx
// IDesignSpec rev   : 5.20.46.0
// XML Revision      : $Revision: 1.238 $

//*** This code is generated with following settings ***
// Reg Width                  : 32
// Address Unit               : 8
// C++ Types int              : hwint
// Bus Type                   : AMBA-AHB
// BigEndian                  : true
// LittleEndian               : true
// Dist. Decode and Readback  : false
//---------------------------------------------------------------------------------------------------------------

//------------------------------------------------
//  BLOCK : BLOCK1 MODULE
//

module Block1_ids #(
    
    //  PARAMETERS
    parameter bus_width   = 32,
    parameter addr_width  = 4,
    
    parameter block_offset  = {(addr_width){1'b0}},
    
    
    parameter Block1_address_width = addr_width
    )
    
    (
    
    //-----------------------------------------------------
    // REGISTER : DATA SIGNALS
    
    output   data_enb,
    
    // READ DATA SIGNAL FOR EACH FIELD
    output [31 : 0] data_D_r,    // FIELD : D
    
    
    
    //-----------------------------------------------------
    // REGISTER : ENB SIGNALS
    
    output   enb_enb,
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  enb_E_r,    // FIELD : E
    
    
    
    //-----------------------------------------------------
    // REGISTER : RESULT SIGNALS
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input  [31 : 0] result_F_in,    // FIELD : F
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   result_F_in_enb,    // FIELD : F
    
    
    
    
    //AMBA signals
    input hclk,     // Bus clock
    input hresetn,     // Bus reset
    input hwrite,     // Transfer direction : HIGH indicates a write transfer and when LOW a read transfer
    input [addr_width-1 : 0] haddr,     // Address bus
    input [bus_width-1 : 0] hwdata,     // Write data bus : Transfer data from the master to the bus slaves during write operations
    output [bus_width-1 : 0] hrdata,     // Read data bus  : Transfer data from bus slaves to the bus master during read operations
    output hready,     // Transfer done  : HIGH indicates that a transfer has finished and when LOW transfer has extended
    input [1 : 0] htrans,     // Transfer type  : NONSEQUENTIAL, SEQUENTIAL, IDLE or BUSY
    input [2 : 0] hsize,     // Byte enable signal
    output [1 : 0] hresp,     // Response signal
    input [3 : 0] hprot,     // Protection control : Provides additional information about a bus access.
    input hsel,     // Slave select Decoder : Indicates that the current transfer is intended for the slave
    input [2 : 0] hburst     // Burst type Master : 4, 8 and 16 beat bursts are supported and the burst may be either incrementing or wrapping
    
    );
    //-----------------------------------------------------
    // REGISTER : DATA SIGNALS
    
    
    wire    data_decode;         // DECODE
    wire    data_wr_valid;       // WRITE VALID
    wire    data_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] data_rd_data;          // READ DATA
    wire    [64-1 : 0] data_offset;  // OFFSET
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg [31 : 0] data_D_q ;      // FIELD : D
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : ENB SIGNALS
    
    
    wire    enb_decode;         // DECODE
    wire    enb_wr_valid;       // WRITE VALID
    wire    enb_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] enb_rd_data;          // READ DATA
    wire    [64-1 : 0] enb_offset;  // OFFSET
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg enb_E_q ;      // FIELD : E
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : RESULT SIGNALS
    
    
    wire    result_decode;         // DECODE
    wire    result_wr_valid;       // WRITE VALID
    wire    result_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] result_rd_data;          // READ DATA
    wire    [64-1 : 0] result_offset;  // OFFSET
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg [31 : 0] result_F_q ;      // FIELD : F
    
    //-----------------------------------------------------
    
    
    
    //AMBA signals
    wire  [3 : 0] hprot_i;
    
    wire  clk;
    wire  reset_l;
    wire  rd_stb;
    wire  rd_wait;
    wire  wr_stb;
    wire  [addr_width-1:0] address;
    wire  [bus_width-1:0] wr_data;
    wire  request;
    wire  rd_data_vld;
    wire  [bus_width-1:0] rd_data;
    wire  error;
    wire [bus_width-1 : 0] reg_enb;
    wire [bus_width/8 -1 : 0] byte_enb;
    
    amba_widget #(.addr_width(addr_width), .bus_width(bus_width)) amba(
            .hclk(hclk),
            .hresetn(hresetn),
            .hsize(hsize),
            .hresp(hresp),
            .hwrite(hwrite),
            .hwdata(hwdata),
            .haddr(haddr),
            .hrdata(hrdata),
            .hready(hready),
            .htrans(htrans),
            .hburst(hburst),
            .hsel(hsel),
            .hprot(hprot),
            .error(error),
            .clk(clk),
            .reset_l(reset_l),
            .byte_enb(byte_enb),
            .request(request),
            .hprot_i(hprot_i),
            .wr_stb(wr_stb),
            .rd_stb(rd_stb),
            .rd_data(rd_data),
            .wr_data(wr_data),
            .address(address),
            .rd_data_vld(rd_data_vld),
            .rd_wait(rd_wait));
    //end widget
    
    assign reg_enb =  {
    {8{byte_enb[3]}} ,
    {8{byte_enb[2]}} ,
    {8{byte_enb[1]}} ,
    {8{byte_enb[0]}}};
    
    
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  DATA
    // ADDRESS       :  0x0                WIDTH : 32
    // HW ACCESS     :  READ-ONLY
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     31:0 : D  ( SW : Read-Write HW : Read-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION   :  NA
    //
    
    
    assign data_wr_valid = data_decode && wr_stb;
    assign data_rd_valid = data_decode && rd_stb;
    assign data_enb      = data_wr_valid;
    assign data_offset = block_offset+'h0;
    assign data_decode  = (address[Block1_address_width-1 : 0]    == data_offset[Block1_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : D
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  32
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :  NA
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                data_D_q  <= 32'b00000000000000000000000000000000;
            end
        else
            begin
                
            if (data_wr_valid)   // D : SW Write
                begin
                    data_D_q <= ( wr_data[31 : 0] & reg_enb[31 : 0] ) | (data_D_q & (~reg_enb[31 : 0]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign data_D_r  =  data_D_q ;    // Field : D
    assign data_rd_data = data_rd_valid ? {data_D_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  ENB
    // ADDRESS       :  0x4                WIDTH : 32
    // HW ACCESS     :  READ-ONLY
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //        0 : E  ( SW : Read-Write HW : Read-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION   :  NA
    //
    
    
    assign enb_wr_valid = enb_decode && wr_stb;
    assign enb_rd_valid = enb_decode && rd_stb;
    assign enb_enb      = enb_wr_valid;
    assign enb_offset = block_offset+'h4;
    assign enb_decode  = (address[Block1_address_width-1 : 0]    == enb_offset[Block1_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : E
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :  NA
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                enb_E_q  <= 1'b0;
            end
        else
            begin
                
            if (enb_wr_valid)   // E : SW Write
                begin
                    enb_E_q <= ( wr_data[0] & reg_enb[0] ) | (enb_E_q & (~reg_enb[0]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign enb_E_r  =  enb_E_q ;    // Field : E
    assign enb_rd_data = enb_rd_valid ? {31'b0 ,enb_E_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  RESULT
    // ADDRESS       :  0x8                WIDTH : 32
    // HW ACCESS     :  WRITE-ONLY
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     31:0 : F  ( SW : Read-Write HW : Write-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION   :  NA
    //
    
    
    assign result_wr_valid = result_decode && wr_stb;
    assign result_rd_valid = result_decode && rd_stb;
    assign result_offset = block_offset+'h8;
    assign result_decode  = (address[Block1_address_width-1 : 0]    == result_offset[Block1_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F
    // HW ACCESS  :  WRITE-ONLY                          WIDTH  :  32
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :  NA
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                result_F_q  <= 32'b00000000000000000000000000000000;
            end
        else
            begin
            if (result_F_in_enb)   // F : HW Write
                begin
                    result_F_q <= result_F_in;
                end
            else
                begin
                    
                if (result_wr_valid)   // F : SW Write
                    begin
                        result_F_q <= ( wr_data[31 : 0] & reg_enb[31 : 0] ) | (result_F_q & (~reg_enb[31 : 0]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    assign result_rd_data = result_rd_valid ? {result_F_q} : 32'b00000000000000000000000000000000;
    
    
    
    
    
    
    
    
    
    assign rd_data = data_rd_data |
    enb_rd_data |
    result_rd_data;
    
    
    assign error = 0;
    
    assign request      =  1;
    assign rd_data_vld   =  rd_stb;
    assign rd_wait       =  1;
    
    
endmodule
